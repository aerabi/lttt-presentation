\begin{frame}[t,plain]
\titlepage
\end{frame}

% a hack, since colons do not render in the math environments
\renewcommand{\colon}{\mbox{~:~}}

\newcommand{\ang}[1]{\left\langle #1 \right\rangle}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\renewcommand{\diamond}{\lozenge}
\newcommand{\T}{\mathfrak{T}}
\newcommand{\A}{\mathfrak{A}}
\renewcommand{\t}{\mathfrak{t}}
\newcommand{\e}{\mathfrak{e}}
\renewcommand{\v}{\mathfrak{v}}
\newcommand{\n}{\mathfrak{n}}

\begin{frame}[fragile]
    \frametitle{Main Goal}
  
    Verify linear-time temporal type theory, LTTT.
\end{frame}

\begin{frame}{Overview}
\tableofcontents
\end{frame}

\section{Preliminaries}

\subsection{Intuitionistic Propositional Logic}

\begin{frame}{Intuitionistic Logic}
    Intuitionistic propositional logic, IPL, differs from the classical one, by rejecting the law of excluded middle (\textit{principium tertii exclusi}).
    
    As a result, the following rules are not valid:
    \[
    \infer[\mbox{RAA}]{\Gamma \vdash \alpha}{\Gamma, \neg\alpha \vdash \bot}
    ~~~~ ~~~~
    \infer[\mbox{DNE}]{\Gamma \vdash \alpha}{\Gamma \vdash \neg\neg\alpha}
    \]
\end{frame}

\begin{frame}{Language of IPL}
    The language of IPL is defined by the following grammar:
    \[
    \alpha, \beta ::= \bot \mid a \mid \alpha \rightarrow \beta \mid \alpha \vee \beta \mid \alpha \wedge \beta,
    \]
    where
    \begin{itemize}
        \item $a$ ranges over atomic formulae,
        \item $\bot$ is contradiction or falsity,
        \item $\rightarrow$ is implication, $\vee$ is disjunction, and $\wedge$ is conjunction,
        \item $\neg\alpha$ is defined as $\alpha \rightarrow \bot$,
        \item $\top$ is defined as $\neg\bot$.
    \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{IPL Inference Rules}
    The inference rules for IPL consists of the following (using natural deduction system with sequent):
    \begin{itemize}
        \item Axiom. $\Gamma, \alpha \vdash \alpha$.
        \item Principle of explosion (\textit{ex falso quodlibet}).
        \[
        \infer[\mbox{EFQ}]{\Gamma \vdash \beta}{\Gamma \vdash \bot}
        \]
        \item Implication rules.
        \[
        \infer[\rightarrow\mbox{-I}]{\Gamma \vdash \alpha \rightarrow \beta}{\Gamma, \alpha \vdash \beta}
        ~~~~ ~~~~
        \infer[\rightarrow\mbox{-E}]{\Gamma_1, \Gamma_2 \vdash \beta}{\Gamma_1 \vdash \alpha & \Gamma_2 \vdash \alpha \rightarrow \beta}
        \]
        \item Disjunction rules.
        \[
        \infer[\vee\mbox{-I}]{\Gamma\vdash \alpha_1 \vee \alpha_2}{\Gamma \vdash \alpha_i}
        ~~~~ ~~~~
        \infer[\vee\mbox{-E}]{\Gamma_1, \Gamma_2 \vdash \beta}{
            \Gamma_1 \vdash \alpha_1 \vee \alpha_2
            &
            \Gamma_2, \alpha_1 \vdash \beta
            &
            \Gamma_2, \alpha_2 \vdash \beta
        }
        \]
        \item Conjunction rules.
        \[
        \infer[\wedge\mbox{-I}]{\Gamma_1, \Gamma_2 \vdash \alpha_1 \wedge \alpha_2}{
            \Gamma_1 \vdash \alpha_1
            &
            \Gamma_2 \vdash \alpha_2
        }
        ~~~~ ~~~~
        \infer[\wedge\mbox{-E}]{\Gamma \vdash \alpha_i}{
            \Gamma \vdash \alpha_1 \wedge \alpha_2
        }
        \]
    \end{itemize}
    
    \begin{example}
    Prove that $\Gamma \vdash \top$ for all $\Gamma$.
    \end{example}
\end{frame}

\subsection{Curry--Howard Correspondence}

\begin{frame}{Simply Typed Lambda Calculus}
    The language of simply typed lambda calculus, TLC($\rightarrow$), is defined by:
    \begin{align*}
    \T, \mathfrak{S} &::= T \mid \T \rightarrow \mathfrak{S}, \\
    \t &::= x \mid \lambda x. \t \mid \t_1 \t_2.
    \end{align*}
    
    Typing rules consist of:
    \begin{itemize}
        \item Axiom. $\Gamma, x : \T \vdash x : \T$.
        \item Implication rules.
        \[
        \infer[\rightarrow\mbox{-I}]{\Gamma \vdash \lambda x. \t : \T \rightarrow \mathfrak{S}}{\Gamma, x : \T \vdash \t : \mathfrak{S}}
        ~~~~ ~~~~
        \infer[\rightarrow\mbox{-E}]{\Gamma \vdash \t_1\t_2 : \mathfrak{S}}{
            \Gamma \vdash \t_1 : \T \rightarrow \mathfrak{S}
            &
            \Gamma \vdash \t_2 : \T
        }
        \]
    \end{itemize}
\end{frame}

\begin{frame}{More Types}
\begin{itemize}
    \item Unit type, is a type inhabited by a single term.
    \begin{tabular}{l|cc}
        Language & Type & Value \\
        \hline
        Scala & \texttt{Unit} & \texttt{()} \\
        Haskel, Rust, Swift & \texttt{()} & \texttt{()} \\
        ML, OCaml, F\# & \texttt{unit} & \texttt{()} \\
        TypeScript & \texttt{undefined} & \texttt{undefined}
    \end{tabular}
    \item A bottom type, is a type that has no value. E.g. \texttt{Nothing} in Scala and \texttt{never} or \texttt{void} in TypeScript.
    \item Union type (aka tagged union or sum type) is a union of other types. The actual type is usually decided in the runtime by pattern matching.
    
    \texttt{type Tree = Node | Leaf;}
    \item Product type is usually realized as the type of tuples.
    
\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Extending Simply Typed Lambda Calculus}
    One can extend TLC($\rightarrow$) by adding tuples, unions, and unit and bottom type:
    \begin{align*}
    i ::=&~ 1 \mid 2, \\
    \T, \mathfrak{S} ::=&~ T \mid \mathtt{Unit} \mid \mathtt{Void} \mid \T \rightarrow \mathfrak{S} \mid \T \times \mathfrak{S} \mid \T + \mathfrak{S}, \\
    \t ::=&~ x \mid \lambda x. \t \mid \t_1 \t_2 \mid () \mid (\t_1, \t_2) \mid \pi_i(\t) \mid \iota_i(\t) \\ &\mid \mathtt{case}~\t~\mathtt{of}~(\iota_1 x_1 \rightarrow \t_1 \mid \iota_2 x_2 \rightarrow \t_2) \\
    &\mid \mathtt{case}~\t~\mathtt{of}~().
    \end{align*}
    
    The additional rules are:
    \begin{itemize}
        \item Unit and bottom type rules.
        \[
        \infer[\mathtt{Unit}\mbox{-I}]{\Gamma \vdash () : \mathtt{Unit}}{}
        ~~~~ ~~~~
        \infer[\mathtt{Void}\mbox{-E}]{\Gamma \vdash \mathtt{case}~\t~\mathtt{of}~() : \mathfrak{S}}{\Gamma \vdash \t : \mathtt{Void}}
        \]
        \item Tuple rules.
        \[
        \infer[\times\mbox{-I}]{\Gamma \vdash (\t_1, \t_2) : \T_1 \times \T_2}{\Gamma \vdash \t_1 : \T_1 & \Gamma \vdash \t_2 : \T_2}
        ~~~~ ~~~~
        \infer[\times\mbox{-E}]{\Gamma \vdash \pi_i \t : \T_i}{\Gamma \vdash \t : \T_1 \times \T_2}
        \]
        \item Union type rules.
        \begin{gather*}
        \infer[+\mbox{-I}]{\Gamma \vdash \iota_i \t : \T_1 + \T_2}{\Gamma \vdash \t : \T_i}
        \\ \\
        \infer[+\mbox{-E}]{\Gamma \vdash \mathtt{case}~\t~\mathtt{of}~(\iota_1 x_1 \rightarrow \t_1 \mid \iota_2 x_2 \rightarrow \t_2) : \mathfrak{S}}{
            \Gamma \vdash \t : \T_1 + \T_2
            &
            \Gamma, x_1 : \T_1 \vdash \t_1 : \mathfrak{S}
            &
            \Gamma, x_2 : \T_2 \vdash \t_2 : \mathfrak{S}
        }
        \end{gather*}
    \end{itemize}
    
    We call the extended TLC($\rightarrow$), TLC($\rightarrow, \times, +, \mathtt{Unit}, \mathtt{Void}$) or simply TLC.
\end{frame}

\begin{frame}{Curry--Howard Correspondence}
\begin{theorem}[\cite{Howard1969TheFN}]
The types in $\mathrm{TLC}$ form an $\mathrm{IPL}$. Furthermore:
\begin{itemize}
    \item If $\Gamma \vdash \t : \alpha$ then $\pi_2[\Gamma] \vdash \alpha$,
    \item If $\Delta \vdash \alpha$ then there is a $\Gamma$ and a $\t$ that $\Delta = \pi_2[\Gamma]$ and $\Gamma \vdash \t : \alpha$.
\end{itemize}
\end{theorem}
\end{frame}

\subsection{Linear Logic}

\begin{frame}{Structural Rules}
    \begin{itemize}
        \item \textbf{Weakening}. Which states that hypotheses of a sequent could be extended.
        \begin{gather*}
            \infer=[\mbox{Weak}]{\Gamma_1, \alpha, \Gamma_2 \vdash \beta}{\Gamma_1, \Gamma_2 \vdash \beta}
            ~~~~ ~~~~
            \infer=[\mbox{Weak}]{\Gamma_1, x : \A, \Gamma_2\vdash \t : \mathfrak{B}}{\Gamma_1, \Gamma_2\vdash \t : \mathfrak{B}}
        \end{gather*}
        \item \textbf{Contraction}. Which states that two similar (or unifiable) hypotheses can be replaced by a single hypothesis.
        \begin{gather*}
            \infer=[\mbox{Contr}]{\Gamma_1, \alpha, \Gamma_2 \vdash \beta}{\Gamma_1, \alpha, \alpha, \Gamma_2 \vdash \beta}
            ~~~~ ~~~~
            \infer=[\mbox{Contr}]{\Gamma_1, x : \A, \Gamma_2 \vdash \t : \mathfrak{B}}{\Gamma_1, x : \A, x : \A, \Gamma_2 \vdash \t : \mathfrak{B}}
        \end{gather*}
        \item \textbf{Exchange}. Which states that two hypotheses may be swapped.
        \begin{gather*}
            \infer=[\mbox{Exch}]{\Gamma_1, \alpha_2, \alpha_1, \Gamma_2 \vdash \beta}{\Gamma_1, \alpha_1, \alpha_2, \Gamma_2 \vdash \beta}
            ~~~~ ~~~~
            \infer=[\mbox{Exch}]{\Gamma_1, x_2 : \A_2, x_1 : \A_1 \Gamma_2 \vdash \t : \mathfrak{B}}{\Gamma_1, x_1 : \A_1, x_2 : \A_2, \Gamma_2 \vdash \t : \mathfrak{B}}
        \end{gather*}
    \end{itemize}
\end{frame}

\begin{frame}{Substructural Logics / Type Systems}
    \begin{table}[!ht]
    \centering
    \begin{tabular}{l|ccc}
         & W & C & E \\
        \hline
        Unrestricted & \checkmark & \checkmark & \checkmark \\
        Affine & \checkmark &  & \checkmark \\
        Relevant &  & \checkmark & \checkmark \\
        Linear & & & \checkmark \\
        Ordered
    \end{tabular}
    \caption{Substructural logics / type systems}
    \label{tab:my_label}
\end{table}

\begin{itemize}
    \item \textbf{Affine}. Every variable can be used at most once.
    \item \textbf{Relevant}. Every variable must be used at least once.
    \item \textbf{Linear}. Every variable must be used exactly once.
    \item \textbf{Ordered}. Every variable must be used exactly once and in the order in which it is introduced.
\end{itemize}
\end{frame}

\begin{frame}{Linear Logic}
    The linear logic \cite{DBLP:journals/tcs/Girard87}, LL$(0, \multimap, \oplus, \otimes, !)$ or simply LL, consists of the following language:
    \[
    \alpha ::= 0 \mid a \mid \alpha \multimap \alpha \mid \alpha \oplus \alpha \mid \alpha \otimes \alpha \mid~ !\alpha.
    \]
    
    \begin{itemize}
        \item $0$ is linear version of $\bot$,
        \item $!$ is called \textit{of course} or \textit{bang} and makes the formulae non-linear,
        \item $\multimap$ is bilinear version of implication,
        \item $\oplus$ is called \textit{additive disjunction} is the bilinear version of or,
        \item $\otimes$ is called \textit{multiplicative conjunction} or \textit{tensor} is the bilinear version of and.
    \end{itemize}
\end{frame}

\begin{frame}{Linear/Non-Linear Logic}
    The linear/non-linear logic \cite{DBLP:conf/csl/Benton94}, or simply LNL, consists of the following language:
    \begin{align*}
        &\tau ::= \bot \mid t \mid \tau \times \tau \mid \tau + \tau \mid \tau \rightarrow \tau \mid \ceil{\alpha}, \\
        &\alpha ::= 0 \mid a \mid \alpha \otimes \alpha \mid \alpha \oplus \alpha \mid \alpha \multimap \alpha \mid \floor{\tau}.
    \end{align*}
    \begin{itemize}
        \item $\ceil{\cdot}$ is called \textit{lift},
        \item $\floor{\cdot}$ is called \textit{lower}.
    \end{itemize}
\end{frame}

\section{Linear-Time Temporal Type Theory}

\section{Coq Implementation}

\section{TypeScript Implementation}

\begin{frame}[t,allowframebreaks]
\nocite{*}
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{ref.bib}
\end{frame}
